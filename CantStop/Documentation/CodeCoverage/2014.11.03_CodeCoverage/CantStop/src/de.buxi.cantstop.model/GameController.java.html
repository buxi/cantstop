<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>GameController.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">test (03.11.2014 05:56:13)</a> &gt; <a href="../../index.html" class="el_group">CantStop</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">de.buxi.cantstop.model</a> &gt; <span class="el_source">GameController.java</span></div><h1>GameController.java</h1><pre class="source lang-java linenums">package de.buxi.cantstop.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import de.buxi.cantstop.service.TooManyPlayerException;

/**
 * It controls the whole game
 * @author buxi
 *
 */
public class GameController implements Serializable{
			
<span class="fc" id="L26">	Log log = LogFactory.getLog(GameController.class);</span>
	
	private static final long serialVersionUID = -6919670618517317954L;
	public static final int DEFAULT_FIRST_PLAYER_NUM = 0;
	public static final int MINIMUM_PLAYER_NUMBER = 2;
	public static final int MAXIMUM_PLAYER_NUMBER = 4;
	private Map&lt;Color, Player&gt; playerMap;
	private List&lt;Player&gt; playersInOrder;  
	private Board board;
	private DiceManager diceManager;
	private Map&lt;Color, Collection&lt;Marker&gt;&gt; allMarkers;
	private List&lt;Climber&gt; climbers;
	private int actualPlayerNumber;
	private GameState gameState;
	private Collection&lt;TwoDicesPair&gt; wrongPairs;
	private String errorMessage;

	private UsedPairInfoTO lastUsedPairInfo;
	
	/**
	 * @return the lastThrow
	 */
	public List&lt;Dice&gt; getLastThrow() {
<span class="fc" id="L49">		return diceManager.getLastThrow();</span>
	}

	/**
	 * @return the errorMessage
	 */
	public String getErrorMessage() {
<span class="fc" id="L56">		return errorMessage;</span>
	}

	public GameController(Map&lt;Color, Player&gt;players, Board board,
			DiceManager diceManager,
			Map&lt;Color, Collection&lt;Marker&gt;&gt; markers,
			List&lt;Climber&gt; climbers) {
<span class="fc" id="L63">		super();</span>
<span class="fc" id="L64">		this.playerMap = players;</span>
<span class="fc" id="L65">		this.playersInOrder = new ArrayList&lt;Player&gt;(4);</span>
<span class="fc" id="L66">		this.board = board;</span>
<span class="fc" id="L67">		this.diceManager = diceManager;</span>
<span class="fc" id="L68">		this.allMarkers = markers;</span>
<span class="fc" id="L69">		this.climbers = climbers;</span>
<span class="fc" id="L70">		this.gameState = GameState.INIT;</span>
<span class="fc" id="L71">		this.wrongPairs = new ArrayList&lt;TwoDicesPair&gt;(3);</span>
<span class="pc bpc" id="L72" title="1 of 4 branches missed.">		if (players != null &amp;&amp; players.size() &gt;= GameController.MINIMUM_PLAYER_NUMBER) {</span>
<span class="fc" id="L73">			this.gameState = GameState.ENOUGH_PLAYER;</span>
		}
<span class="fc" id="L75">	}</span>

	/**
	 * @return the wrongPairs
	 */
	public Collection&lt;TwoDicesPair&gt; getWrongPairs() {
<span class="fc" id="L81">		return wrongPairs;</span>
	}
	
	/**
	 * @return the gameState
	 */
	public GameState getGameStatus() {
<span class="fc" id="L88">		return gameState;</span>
	}

	/**
	 * place the players in standard order
	 */
	public void determinePlayerOrderStandard() {
		//tested in GameControllerSetupTest
<span class="fc" id="L96">		this.playersInOrder = new ArrayList&lt;Player&gt;(4);</span>
<span class="fc" id="L97">		Set&lt;Entry&lt;Color, Player&gt;&gt; players = playerMap.entrySet();</span>
<span class="fc" id="L98">		int i = 0;</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">		for (Entry&lt;Color, Player&gt; entry : players) {</span>
<span class="fc" id="L100">			playersInOrder.add(entry.getValue());</span>
<span class="fc" id="L101">			entry.getValue().setOrder(i);</span>
<span class="fc" id="L102">			i++; </span>
		}
<span class="fc" id="L104">	}</span>

	/**
	 * distribute markers onto players, player color and marker color will be the same
	 * @param markers to distribute
	 */
	protected void distributeMarkers(Map&lt;Color, Collection&lt;Marker&gt;&gt; markers) {
<span class="fc bfc" id="L111" title="All 2 branches covered.">		for (Color markerColor : markers.keySet()) {</span>
<span class="fc" id="L112">			Player player = this.playerMap.get(markerColor);</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">			if (player == null ) {</span>
<span class="fc" id="L114">				throw new PlayerNotFoundException(markerColor + &quot; Player not found&quot;);</span>
			}
<span class="fc" id="L116">			player.addMarkers(markers.get(player.getColor()));</span>
		}
<span class="fc" id="L118">	}</span>
	
	/**
	 * @return the playerMap
	 */
	public Map&lt;Color, Player&gt; getPlayerMap() {
<span class="fc" id="L124">		return playerMap;</span>
	}

	/**
	 * @return the board
	 */
	public Board getBoard() {
<span class="fc" id="L131">		return board;</span>
	}

	/**
	 * @return the diceManager
	 */
	public DiceManager getDiceManager() {
<span class="fc" id="L138">		return diceManager;</span>
	}

	/**
	 * @return the allMarkers
	 */
	public Map&lt;Color, Collection&lt;Marker&gt;&gt; getAllMarkers() {
<span class="fc" id="L145">		return allMarkers;</span>
	}

	/**
	 * @return the climbers
	 */
	public List&lt;Climber&gt; getClimbers() {
<span class="fc" id="L152">		return climbers;</span>
	}
	
	/**
	 * @return the playersInOrder
	 */
	public List&lt;Player&gt; getPlayersInOrder() {
<span class="fc" id="L159">		return playersInOrder;</span>
	}
	
	/**
	 * @return the actualPlayerNumber
	 */
	public int getActualPlayerNumber() {
<span class="fc" id="L166">		return actualPlayerNumber;</span>
	}
	
	public Player getPlayer(Color color) {
<span class="fc" id="L170">		Player player = this.playerMap.get(color);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">		if (player == null ) {</span>
<span class="nc" id="L172">			throw new PlayerNotFoundException(color + &quot; Player not found&quot;);</span>
		}
<span class="fc" id="L174">		return player;</span>
	}
	
	/**
	 * gives the free climbers to the actual player
	 */
	protected void distributeFreeClimbers() {
<span class="fc" id="L181">		this.getActualPlayer().addClimbers(this.getClimbers());</span>
<span class="fc" id="L182">		this.climbers.clear();</span>
<span class="fc" id="L183">	}</span>
	
	/**
	 * starts a new round of the game
	 * distributes the free climbers to the aktual player
	 * @return 
	 * @throws InvalidWayNumberException 
	 * @throws DiceNotThrownException 
	 */
	public GameTransferObject doStartGameTurn() throws DiceNotThrownException, InvalidWayNumberException {
<span class="fc" id="L193">		checkGameStatus(Arrays.asList(GameState.IN_GAME));</span>
<span class="fc" id="L194">		distributeFreeClimbers();</span>
<span class="fc" id="L195">		this.gameState = GameState.IN_ROUND;</span>
<span class="fc" id="L196">		this.lastUsedPairInfo = null;</span>
<span class="fc" id="L197">		return this.doGetTransferObject();</span>
	}
	
	/**
	 * @return 
	 * @throws RopePointInvalidUsageException 
	 * @throws NoMarkerIsAvailableException 
	 * @throws NoClimberOnWayException 
	 * @throws InvalidClimberMovementException 
	 * @throws InvalidWayNumberException 
	 * @throws DiceNotThrownException 
	 */
	public GameTransferObject doEndGameTurn() throws NoMarkerIsAvailableException, RopePointInvalidUsageException, NoClimberOnWayException, InvalidClimberMovementException, InvalidWayNumberException, DiceNotThrownException {
<span class="fc" id="L210">		checkGameStatus(Arrays.asList(GameState.IN_ROUND, GameState.NO_OTHER_PAIR_AVAILABLE_ROUND_FINISHED));</span>
		// marks the climbers
<span class="fc" id="L212">		this.errorMessage = null;</span>
<span class="fc" id="L213">		endGameturn();</span>
<span class="fc" id="L214">		return this.doGetTransferObject();</span>
	}

	/**
	 * @throws NoMarkerIsAvailableException
	 * @throws RopePointInvalidUsageException
	 * @throws InvalidClimberMovementException
	 * @throws NoClimberOnWayException
	 * @throws InvalidWayNumberException
	 */
	protected void endGameturn() throws NoMarkerIsAvailableException,
			RopePointInvalidUsageException, InvalidClimberMovementException,
			NoClimberOnWayException, InvalidWayNumberException {
<span class="fc" id="L227">		Player actualPlayer = getActualPlayer();</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">		if (GameState.NO_OTHER_PAIR_AVAILABLE_ROUND_FINISHED.equals(gameState)) {</span>
<span class="fc" id="L229">			this.climbers = board.removeClimbers();</span>
<span class="fc" id="L230">		}</span>
		else {
<span class="fc" id="L232">			this.climbers = board.markClimbers(actualPlayer);</span>
<span class="fc" id="L233">			Collection&lt;Hut&gt; usedHuts = board.getBlockedHuts(actualPlayer);</span>
			//remove other markers from the rope 
<span class="fc" id="L235">			Map&lt;Color,Collection&lt;Marker&gt;&gt; freeMarkers = board.removeMarkersFromBlockedWays(usedHuts);</span>
			// free Markers back to player
<span class="fc" id="L237">			distributeMarkers(freeMarkers);</span>
			// TODO GameEnde Condition
<span class="fc bfc" id="L239" title="All 2 branches covered.">			if (usedHuts.size() == 3) {</span>
<span class="fc" id="L240">				this.gameState = GameState.GAME_WIN;</span>
<span class="fc" id="L241">				this.errorMessage=&quot;STATE_GAME_WIN&quot;;</span>
<span class="fc" id="L242">				return;</span>
			}
		}
		
<span class="fc" id="L246">		this.nextPlayer();</span>
<span class="fc" id="L247">		distributeFreeClimbers();</span>
		// notify diceManager the throw was used, needs to be reset
<span class="fc" id="L249">		this.diceManager.reset();</span>
<span class="fc" id="L250">		this.gameState = GameState.IN_ROUND;</span>
<span class="fc" id="L251">	}</span>
	
	/**
	 * choose the next player and gives diceManager and climbers
	 */
	protected void nextPlayer() {
<span class="fc" id="L257">		Player oldPlayer = getActualPlayer(); </span>
<span class="fc" id="L258">		this.actualPlayerNumber++;</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">		if (actualPlayerNumber &gt; playersInOrder.size()-1) {</span>
<span class="fc" id="L260">			actualPlayerNumber = 0;</span>
		}
<span class="fc" id="L262">		diceManager.giveDices(getActualPlayer());</span>
<span class="fc" id="L263">		getActualPlayer().addClimbers(oldPlayer.removeClimbers());</span>
<span class="fc" id="L264">	}</span>

	/**
	 * @return actual Player
	 */
	public Player getActualPlayer() {
<span class="fc" id="L270">		return playersInOrder.get(this.actualPlayerNumber);</span>
	}
	
	/**
	 * @param expectedStatuses with or
	 * @throws InvalidGameStateException 
	 */
	private void checkGameStatus(List&lt;GameState&gt; expectedStatuses) {
<span class="fc bfc" id="L278" title="All 2 branches covered.">		if (!expectedStatuses.contains(this.getGameStatus())) {</span>
<span class="fc" id="L279">			throw new InvalidGameStateException(&quot;actual status:&quot;+this.getGameStatus()+&quot; expected statuses:&quot;+expectedStatuses);</span>
		}
<span class="fc" id="L281">	}</span>
	/**
	 * determine first player and gives DiceManager
	 * @return 
	 * @throws InvalidWayNumberException 
	 * @throws DiceNotThrownException 
	 * @throws NotEnoughPlayerException 
	 */
	public GameTransferObject doGameStart() throws  InvalidWayNumberException, DiceNotThrownException {
<span class="fc" id="L290">		checkGameStatus(Arrays.asList(GameState.ENOUGH_PLAYER));</span>
<span class="fc" id="L291">		determineFirstPlayer();</span>
<span class="fc" id="L292">		determinePlayerOrderStandard(); </span>
		// distributes Markers
<span class="fc" id="L294">		Map&lt;Color, Collection&lt;Marker&gt;&gt; playerMarkers = new HashMap&lt;Color, Collection&lt;Marker&gt;&gt;();</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">		for (Player player: playersInOrder) {</span>
<span class="fc" id="L296">			playerMarkers.put(player.getColor(), this.allMarkers.get(player.getColor()));</span>
<span class="fc" id="L297">			this.allMarkers.remove(player.getColor());</span>
		}
<span class="fc" id="L299">		distributeMarkers(playerMarkers);</span>

<span class="fc" id="L301">		this.gameState = GameState.IN_GAME;</span>
		 
<span class="fc" id="L303">		diceManager.giveDices(getActualPlayer());</span>
<span class="fc" id="L304">		return this.doGetTransferObject();</span>
	}

	

	/**
	 * DEFAULT_FIRST_PLAYER_NUM = 0
	 */
	protected void determineFirstPlayer() {
<span class="fc" id="L313">		this.actualPlayerNumber = DEFAULT_FIRST_PLAYER_NUM;</span>
<span class="fc" id="L314">	}</span>
	
	public Collection&lt;Dice&gt; getDices() {
<span class="fc" id="L317">		DiceManager diceManager = getDiceManager();</span>
<span class="fc" id="L318">		return diceManager.getDicesClone();</span>
	}

	public List&lt;TwoDicesPair&gt; getPossiblePairs() throws DiceNotThrownException, InvalidWayNumberException {
<span class="fc" id="L322">		List&lt;TwoDicesPair&gt; possiblePairs = diceManager.getAllPossiblePairs();</span>
		// decorate with choosable Information
<span class="fc" id="L324">		return addChoosableInformation(possiblePairs);</span>
	}
	
	//TODO UNITTEST ?
	public List&lt;TwoDicesPair&gt; getPairsToChoose() throws DiceNotThrownException, InvalidWayNumberException {
<span class="fc" id="L329">		List&lt;TwoDicesPair&gt; possiblePairs = this.getPossiblePairs();</span>
<span class="fc" id="L330">		List&lt;TwoDicesPair&gt; choosablePairs = new ArrayList&lt;TwoDicesPair&gt;();</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">		for (TwoDicesPair twoDicesPair : possiblePairs) {</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">			if (!PairChoiceInfo.NOTCHOOSABLE.equals(twoDicesPair.getPairChoiceInfo())) {</span>
<span class="fc" id="L333">				choosablePairs.add(twoDicesPair);</span>
			}
		}
<span class="fc" id="L336">		return choosablePairs;</span>
	}
	
	public Map&lt;String, TwoDicesPair&gt; getPairsToChooseWithId() throws DiceNotThrownException, InvalidWayNumberException {
<span class="fc" id="L340">		Map&lt;String, TwoDicesPair&gt; result = new HashMap&lt;String, TwoDicesPair&gt;();</span>
<span class="fc" id="L341">		List&lt;TwoDicesPair&gt; possiblePairs = this.getPairsToChoose();</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">		for (TwoDicesPair twoDicesPair : possiblePairs) {</span>
<span class="fc" id="L343">			result.put(twoDicesPair.generateId(), twoDicesPair);</span>
		}
<span class="fc" id="L345">		return result;</span>
	}
	
	/**
	 * Decorate the pairs with PairChoiceInfo
	 * @param possiblePairs
	 * @return
	 * @throws InvalidWayNumberException
	 * @throws DiceNotThrownException
	 */
	protected List&lt;TwoDicesPair&gt; addChoosableInformation(
			List&lt;TwoDicesPair&gt; possiblePairs) throws InvalidWayNumberException, DiceNotThrownException {
<span class="fc" id="L357">		Player player = this.getActualPlayer(); </span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">		for (TwoDicesPair twoDicePair : possiblePairs) {</span>
<span class="fc" id="L359">			Way way1 = board.getWayByNumber(twoDicePair.getFirstSum());</span>
<span class="fc" id="L360">			Way way2 = board.getWayByNumber(twoDicePair.getSecondSum());</span>
			
			// blocked Ways can not be chosen
<span class="fc bfc" id="L363" title="All 4 branches covered.">			if (way1.isBlocked() &amp;&amp; way2.isBlocked() ||</span>
<span class="pc bpc" id="L364" title="1 of 4 branches missed.">				way1.isBlocked() &amp;&amp; way2.isClimberInHut() ||</span>
<span class="pc bpc" id="L365" title="3 of 4 branches missed.">				way2.isBlocked() &amp;&amp; way1.isClimberInHut() ||</span>
<span class="fc bfc" id="L366" title="All 4 branches covered.">				way1.isClimberInHut() &amp;&amp; way2.isClimberInHut()</span>
				) {
<span class="fc" id="L368">				twoDicePair.setPairChoiceInfo(PairChoiceInfo.NOTCHOOSABLE);</span>
<span class="fc" id="L369">				continue;</span>
			} 
			// all climber on the board
<span class="fc bfc" id="L372" title="All 2 branches covered.">			if (player.getClimbers().size() == 0) {</span>
<span class="fc bfc" id="L373" title="All 4 branches covered.">				if ( !way1.isClimberOnRope() &amp;&amp; !way2.isClimberOnRope()) {</span>
<span class="fc" id="L374">					twoDicePair.setPairChoiceInfo(PairChoiceInfo.NOTCHOOSABLE);</span>
<span class="fc" id="L375">					continue;</span>
				}
<span class="pc bpc" id="L377" title="3 of 4 branches missed.">				if (way1.isClimberInHut() &amp;&amp; !way2.isClimberOnRope()) {</span>
<span class="nc" id="L378">					twoDicePair.setPairChoiceInfo(PairChoiceInfo.NOTCHOOSABLE);</span>
<span class="nc" id="L379">					continue;</span>
				}
<span class="pc bpc" id="L381" title="3 of 4 branches missed.">				if (way2.isClimberInHut() &amp;&amp; !way1.isClimberOnRope()) {</span>
<span class="nc" id="L382">					twoDicePair.setPairChoiceInfo(PairChoiceInfo.NOTCHOOSABLE);</span>
<span class="nc" id="L383">					continue;</span>
				}
			}
			// one climber in the hand
<span class="fc bfc" id="L387" title="All 2 branches covered.">			if (player.getClimbers().size() == 1) {</span>
					// WITHWAYINFO case
					/*  if already 2 Climbers were placed and
					    the pair's sum results no Way, where are the climbers */
<span class="pc bpc" id="L391" title="1 of 4 branches missed.">					if (way1.isFree() &amp;&amp; way2.isFree() &amp;&amp; </span>
<span class="fc bfc" id="L392" title="All 4 branches covered.">						!way1.isClimberOnRope() &amp;&amp; !way2.isClimberOnRope() &amp;&amp;</span>
<span class="fc bfc" id="L393" title="All 4 branches covered.">						!way1.isClimberInHut() &amp;&amp; !way2.isClimberInHut()) {</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">						if (way1.getNumber() == way2.getNumber()) {</span>
<span class="fc" id="L395">							twoDicePair.setPairChoiceInfo(PairChoiceInfo.CHOOSABLE);</span>
<span class="fc" id="L396">						}else {</span>
<span class="fc" id="L397">							twoDicePair.setPairChoiceInfo(PairChoiceInfo.WITHWAYINFO);</span>
						}
<span class="fc" id="L399">						continue;</span>
					}
			}
<span class="fc" id="L402">			twoDicePair.setPairChoiceInfo(PairChoiceInfo.CHOOSABLE);</span>
		}
<span class="fc" id="L404">		return possiblePairs;</span>
	}

	/**
	 * @return 
	 * @throws InvalidWayNumberException 
	 * @throws DiceNotThrownException 
	 * @throws InvalidClimberMovementException 
	 * @throws NoClimberOnWayException 
	 * @throws RopePointInvalidUsageException 
	 * @throws NoMarkerIsAvailableException 
	 */
	public GameTransferObject doThrowDices() throws DiceNotThrownException, InvalidWayNumberException, NoMarkerIsAvailableException, RopePointInvalidUsageException, NoClimberOnWayException, InvalidClimberMovementException {
<span class="fc" id="L417">		checkGameStatus(Arrays.asList(GameState.IN_ROUND));</span>
<span class="fc" id="L418">		this.errorMessage = null;</span>
<span class="fc" id="L419">		diceManager.throwAllDices();</span>
<span class="fc" id="L420">		this.gameState=GameState.DICES_THROWN;</span>
<span class="fc" id="L421">		this.wrongPairs = new ArrayList&lt;TwoDicesPair&gt;(3);</span>
		// checks pairs if they are choosable
<span class="fc bfc" id="L423" title="All 2 branches covered.">		if (!isTherePossiblePair(this.getPossiblePairs())) {</span>
			// GameRound must be finished
<span class="fc" id="L425">			this.gameState=GameState.NO_OTHER_PAIR_AVAILABLE_ROUND_FINISHED;</span>
<span class="fc" id="L426">			this.errorMessage = &quot;STATE_NO_OTHER_PAIR_AVAILABLE_ROUND_FINISHED&quot;;</span>
<span class="fc" id="L427">			log.info(&quot;turn finished, no available pair&quot;);</span>
<span class="fc" id="L428">			endGameturn();</span>
		}
<span class="fc" id="L430">		return this.doGetTransferObject();</span>
	}
	
	/**
	 * JUST FOR TESTING
	 * same as doThrow() but we can set a DiceManager 
	 * @param diceManager 
	 */
	protected void testDoThrow(DiceManager diceManager) throws DiceNotThrownException, InvalidWayNumberException, NoMarkerIsAvailableException, RopePointInvalidUsageException, NoClimberOnWayException, InvalidClimberMovementException {
<span class="fc" id="L439">		this.setDiceManager(diceManager);</span>
<span class="fc" id="L440">		doThrowDices();</span>
<span class="fc" id="L441">	}</span>
	/**
	 * JUST FOR TESTING
	 * @param diceManager the diceManager to set
	 */
	private void setDiceManager(DiceManager diceManager) {
<span class="fc" id="L447">		this.diceManager = diceManager;</span>
<span class="fc" id="L448">	}</span>

	/**
	 * @return true is there is minimum one CHOOSABLE or WITHWAYINFO pair
	 * @throws DiceNotThrownException
	 * @throws InvalidWayNumberException
	 */
	protected boolean isTherePossiblePair(List&lt;TwoDicesPair&gt; possiblePairs)
			throws DiceNotThrownException, InvalidWayNumberException {
<span class="fc" id="L457">		boolean isThereChoosable = false;;</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">		for (TwoDicesPair twoDicePair : possiblePairs) {</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">			if (PairChoiceInfo.CHOOSABLE.equals(twoDicePair.getPairChoiceInfo()) ||</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">				PairChoiceInfo.WITHWAYINFO.equals(twoDicePair.getPairChoiceInfo())) {</span>
<span class="fc" id="L461">				isThereChoosable = true;</span>
			}
		}
<span class="fc" id="L464">		return isThereChoosable;</span>
	}
	
	/**
	 * Executing the chosen pair(with chosen wayNumber) on board
	 * @param wayNumber if a way should be chosen
	 * @return transfer object
	 */
	public GameTransferObject doExecutePairs(TwoDicesPair chosenPair, int wayNumber) throws DiceNotThrownException, RopePointInvalidUsageException, NotAvailableClimberException, InvalidWayNumberException, InvalidClimberMovementException, NoMarkerIsAvailableException, NullClimberException, NoClimberOnWayException {
<span class="fc" id="L473">		checkGameStatus(Arrays.asList(GameState.DICES_THROWN));</span>
<span class="fc" id="L474">		this.errorMessage = null;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">		if (!this.getPossiblePairs().contains(chosenPair)) {</span>
<span class="fc" id="L476">			throw new InvalidPairsException(&quot;Pair:&quot; + chosenPair + &quot;, wayNumber:&quot; + wayNumber);</span>
		}
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">		if (PairChoiceInfo.NOTCHOOSABLE.equals(chosenPair.getPairChoiceInfo())) {</span>
<span class="nc" id="L479">			throw new InvalidPairsException(&quot;Pair is not choosable:&quot; + chosenPair + &quot;, wayNumber:&quot; + wayNumber);</span>
		}  
<span class="fc bfc" id="L481" title="All 2 branches covered.">		if (PairChoiceInfo.WITHWAYINFO.equals(chosenPair.getPairChoiceInfo()) &amp;&amp;</span>
<span class="pc bpc" id="L482" title="1 of 4 branches missed.">			(wayNumber != chosenPair.getFirstSum() &amp;&amp; wayNumber != chosenPair.getSecondSum())) {</span>
<span class="fc" id="L483">				throw new InvalidWayNumberException(&quot;Pair:&quot; + chosenPair + &quot;, wayNumber:&quot; + wayNumber);</span>
		}

<span class="fc" id="L486">		pairExecute(chosenPair, wayNumber, getActualPlayer());</span>
<span class="fc" id="L487">		return this.doGetTransferObject();</span>
	}
	/**
	 * moves climber
	 * @param chosenWayNumber 
	 * @param player
	 * @throws NotAvailableClimberException 
	 * @throws InvalidWayNumberException 
	 * @throws InvalidClimberMovementException 
	 * @throws NoMarkerIsAvailableException 
	 * @throws NullClimberException 
	 * @throws NoClimberOnWayException 
	 */
	protected void pairExecute(TwoDicesPair chosenPair, int chosenWayNumber, Player player) throws DiceNotThrownException, RopePointInvalidUsageException, InvalidWayNumberException, InvalidClimberMovementException, NoMarkerIsAvailableException, NullClimberException, NoClimberOnWayException {
<span class="fc bfc" id="L501" title="All 2 branches covered.">		if (chosenWayNumber&gt;0) {</span>
<span class="fc" id="L502">			Way way = board.getWayByNumber(chosenWayNumber);</span>
			try {
<span class="fc" id="L504">				choseWay(player, way);</span>
<span class="pc" id="L505">			} catch (NotAvailableClimberException e) {</span>
<span class="nc" id="L506">				log.warn(e.getMessage());</span>
			}
<span class="nc" id="L508">		}</span>
		else {
<span class="fc" id="L510">			int wayNumber1 = chosenPair.getFirstSum();</span>
<span class="fc" id="L511">			int wayNumber2 = chosenPair.getSecondSum();</span>
<span class="fc" id="L512">			Way way1 = board.getWayByNumber(wayNumber1);</span>
<span class="fc" id="L513">			Way way2= board.getWayByNumber(wayNumber2);</span>
			try {
<span class="fc" id="L515">				choseWay(player, way1);</span>
<span class="pc" id="L516">			} catch (NotAvailableClimberException e) {</span>
<span class="nc" id="L517">				log.warn(e.getMessage());</span>

			}
			try {
<span class="fc" id="L521">				choseWay(player, way2);</span>
<span class="fc" id="L522">			} catch (NotAvailableClimberException e) {</span>
<span class="fc" id="L523">				log.warn(e.getMessage());</span>
			}
		}
		
		// minimum one Pair successful
<span class="fc" id="L528">		this.gameState=GameState.IN_ROUND;</span>
<span class="fc" id="L529">		this.lastUsedPairInfo = new UsedPairInfoTO(chosenPair, chosenWayNumber, player);</span>
		// notify diceManager the throw was used, needs to be reset
<span class="fc" id="L531">		this.diceManager.reset();</span>
<span class="fc" id="L532">		errorMessage = &quot;STATE_PAIR_USED&quot;;</span>
<span class="fc" id="L533">	}</span>

	/**
	 * Places oder moves climber on the way
	 * if there is no marker on the way then places the climber position 0
	 * if there is a marker on the way then places the climber after the marker 
	 * if there is already a climber on the way then moves it forward (also in the hut)
	 * @param player
	 * @param way
	 * @throws NotAvailableClimberException
	 */
	protected void choseWay(Player player, Way way)
			throws RopePointInvalidUsageException,
			NotAvailableClimberException, InvalidClimberMovementException, NullClimberException {
		// fixing bug2
<span class="pc bpc" id="L548" title="1 of 4 branches missed.">		if (way.isFree() &amp;&amp; !way.isClimberInHut()) {</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">			if (!way.isClimberOnRope() ) {</span>
				// no climber on the way
<span class="fc bfc" id="L551" title="All 2 branches covered.">				if (way.isMarkerOnRope(player.getColor())) {</span>
<span class="fc" id="L552">					way.placeClimberAfterMarker(player.aquireOneClimber(), player.getColor());</span>
<span class="fc" id="L553">				} else {</span>
<span class="fc" id="L554">					way.placeClimberOntoFirstRopePoint(player.aquireOneClimber());	</span>
				}
				
<span class="fc" id="L557">			} else {</span>
				// climber on the way
<span class="fc" id="L559">				way.moveClimber();</span>
			}
		}
<span class="fc" id="L562">	}</span>
	
	/**
	 * Adds a player to the player list
	 * @param playerName
	 * @return playerId (currently the orderId) 
	 * @throws TooManyPlayerException
	 */
	public String doAddPlayer(String playerName) throws TooManyPlayerException {
<span class="fc" id="L571">		checkGameStatus(Arrays.asList(GameState.INIT, GameState.ENOUGH_PLAYER));</span>
		// TODO id should be generated in a better way (for example with Spring)
<span class="fc" id="L573">		Color playerColor = getAFreeColor();</span>
<span class="fc" id="L574">		int playerId = playerMap.keySet().size();</span>
<span class="fc" id="L575">		Player newPlayer = new Player(playerId, playerName, playerColor);</span>
<span class="fc" id="L576">		playerMap.put(playerColor, newPlayer);</span>
<span class="fc" id="L577">		determinePlayerOrderStandard();</span>
<span class="fc" id="L578">		actualPlayerNumber = playerId;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">		if (this.playerMap.keySet().size() &gt;= GameController.MINIMUM_PLAYER_NUMBER) {</span>
<span class="fc" id="L580">			this.gameState = GameState.ENOUGH_PLAYER;</span>
		}
<span class="fc" id="L582">		return Integer.toString(playerId);</span>
	}

	/**
	 * used in game init phase
	 * returns a free color, which is not allocated to any players 
	 * @return a not allocated Color
	 * @throws TooManyPlayerException when there is no free Color left 
	 */
	protected Color getAFreeColor() throws TooManyPlayerException {
<span class="fc" id="L592">		Collection&lt;Color&gt; remainingColorSet = new HashSet&lt;Color&gt;(this.allMarkers.keySet());</span>
<span class="fc" id="L593">		remainingColorSet.removeAll(this.getPlayerMap().keySet());</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">		if (remainingColorSet.isEmpty()) {</span>
<span class="fc" id="L595">			throw new TooManyPlayerException(&quot;No available color&quot;);</span>
		}
<span class="fc" id="L597">		Color[] remainingColors = remainingColorSet.toArray(new Color[0]);</span>
<span class="fc" id="L598">		Color playerColor = remainingColors[0];</span>
<span class="fc" id="L599">		return playerColor;</span>
	}
	
	/**
	 * generates a Transfer Object for client apps
	 * @return new transfer object
	 * @throws DiceNotThrownException
	 * @throws InvalidWayNumberException 
	 */
	public GameTransferObject doGetTransferObject() throws DiceNotThrownException, InvalidWayNumberException {
<span class="fc" id="L609">		GameTransferObject to = new GameTransferObject();</span>
<span class="fc" id="L610">		to.gameState = this.gameState;</span>
<span class="fc" id="L611">		to.actualPlayer = null;</span>
<span class="fc" id="L612">		to.actualPlayerNumber = -1;</span>
<span class="pc bpc" id="L613" title="1 of 4 branches missed.">		if (!GameState.INIT.equals(gameState) &amp;&amp; !GameState.GAME_FINISHED.equals(gameState) ) {</span>
<span class="fc" id="L614">			to.actualPlayer = this.getActualPlayer();</span>
<span class="fc" id="L615">			to.actualPlayerNumber = this.getActualPlayerNumber();</span>
		}
<span class="fc" id="L617">		to.boardDisplay = this.getBoard().display();</span>
<span class="fc" id="L618">		to.playerList = this.getPlayersInOrder();</span>
<span class="fc" id="L619">		to.errorMessage = this.errorMessage;</span>
<span class="fc" id="L620">		to.errorMessageString = &quot;&quot;;</span>
<span class="fc" id="L621">		to.possiblePairs = null;</span>
<span class="fc" id="L622">		to.choosablePairsWithId = null;</span>
<span class="fc" id="L623">		to.dices = null;</span>
<span class="fc" id="L624">		to.lastThrow = this.getLastThrow();</span>
<span class="fc" id="L625">		to.lastUsedPairInfo = this.lastUsedPairInfo;</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">		if (GameState.DICES_THROWN.equals(gameState) ) {</span>
<span class="fc" id="L627">			to.possiblePairs = this.getPossiblePairs();</span>
<span class="fc" id="L628">			to.choosablePairsWithId = this.getPairsToChooseWithId();</span>
<span class="fc" id="L629">			to.dices = this.getDices();</span>
		}
<span class="fc" id="L631">		to.board = this.getBoard();</span>
<span class="fc" id="L632">		to.gameFull = this.isGameFull();</span>
<span class="fc" id="L633">		return to;</span>
	}

	/**
	 * @return true if &lt;code&gt;MAXIMUM_PLAYER_NUMBER&lt;/code&gt; have already joined to the game
	 */
	public boolean isGameFull() {
<span class="fc bfc" id="L640" title="All 2 branches covered.">		if (playerMap.values().size() == MAXIMUM_PLAYER_NUMBER) {</span>
<span class="fc" id="L641">			return true;</span>
		}
<span class="fc" id="L643">		return false;</span>
	}

	/**
	 * removes a player from game
	 * @param playerId which player has the game finished 
	 * @return 
	 * @throws InvalidWayNumberException 
	 * @throws DiceNotThrownException 
	 */
	public GameTransferObject doEndGame(String playerId) throws DiceNotThrownException, InvalidWayNumberException {
<span class="nc" id="L654">		this.gameState = GameState.GAME_FINISHED;</span>
<span class="nc" id="L655">		log.info(&quot;game was finished by player:&quot; + playerId);</span>
<span class="nc" id="L656">		this.errorMessage = &quot;GAMEWASFINISHED&quot;;</span>
<span class="nc" id="L657">		return this.doGetTransferObject();		</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>test (03.11.2014 05:56:13)</div></body></html>